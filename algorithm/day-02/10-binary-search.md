# 10. 二分探索

### 10.1 探索問題とは

探索問題とは、データの集合 (リストなど) の中から、特定の条件を満たす要素を見つけ出す問題のことです。

* 日常生活の例
  * 本棚から特定の本を探す
  * 辞書から特定の単語を探す
  * スマートフォンの連絡先から特定の人の番号を探す
* プログラミングでの重要性
  * データベースからの情報検索
  * 配列やリスト内の要素検索
  * ファイル内のテキスト検索

### 10.2 日常生活での二分探索の例

#### 例：辞書から特定の単語を探す

辞書から特定の単語を探す方法は、二分探索の典型的な例です。

* 辞書はアルファベット順（50音順）にソートされている
* 辞書の真ん中あたりを開く
* 探している単語が開いたページよりも前にあるか後ろにあるかを判断
* それに応じて、前半部分または後半部分だけを探索
* 対象の範囲を半分に絞りながら、同じ手順を繰り返す

この「辞書での単語探し」の手順を自然言語で表現すると、

```
# 辞書での単語探しの基本的な流れ
1. 辞書の範囲（最初のページから最後のページまで）を設定

2. 探索範囲がある限り:
   a. 現在の範囲の真ん中のページを開く
   b. そのページの単語を確認する
   c. もし探している単語と同じなら:
      「見つかりました！」と報告して終了
   d. もし探している単語がそのページより前にあるなら:
      後半部分を除外して前半部分だけを新しい範囲として手順2に戻る
   e. もし探している単語がそのページより後ろにあるなら:
      前半部分を除外して後半部分だけを新しい範囲として手順2に戻る

3. 探索範囲がなくなったら:
   「見つかりませんでした」と報告
```

この方法は、ページを1ページずつめくる方法（線形探索）と比べて、大幅に効率的です。

### 10.3 二分探索のアルゴリズム

{% embed url="https://hokachan1989.github.io/spring-training-2025/binary_search.html" %}

#### 基本的な考え方

二分探索（バイナリサーチとも呼ばれます）は、**ソートされたデータ**を対象とする高速な探索アルゴリズムです。

* 探索範囲の中央にある要素から探索を始める
* 中央の要素と探している値を比較し、探索範囲を半分に絞る
* 新しい探索範囲に対して同じ処理を繰り返す
* 探索範囲がなくなるか、値が見つかるまで続ける

#### Pythonによる実装

{% code lineNumbers="true" %}
```python
def binary_search(sorted_list, target):
    """
    二分探索でソート済みリスト内の要素を探す
    
    引数:
    sorted_list -- 探索対象のソート済みリスト
    target -- 探している値
    
    戻り値:
    見つかった場合はインデックス、見つからなかった場合は-1
    """
    # 探索範囲の初期設定
    left = 0
    right = len(sorted_list) - 1
    
    # 探索範囲がある限り繰り返す
    while left <= right:
        # 中央のインデックスを計算
        mid = (left + right) // 2
        
        # 中央の要素が探している値と等しいか確認
        if sorted_list[mid] == target:
            return mid  # 見つかった場合、そのインデックスを返す
        
        # 中央の要素が探している値より大きい場合、左半分を探索
        elif sorted_list[mid] > target:
            right = mid - 1
        
        # 中央の要素が探している値より小さい場合、右半分を探索
        else:
            left = mid + 1
    
    # リスト内を全て探しても見つからなかった場合
    return -1
```
{% endcode %}

#### 二分探索の使用例

{% code lineNumbers="true" %}
```python
# ソート済みの数値のリスト
numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]

# 値11を探す
result = binary_search(numbers, 11)

# 結果の表示
if result != -1:
    print(f"値11はインデックス{result}の位置にあります")
else:
    print("値11は見つかりませんでした")

# 値12を探す（リストにない値）
result = binary_search(numbers, 12)

# 結果の表示
if result != -1:
    print(f"値12はインデックス{result}の位置にあります")
else:
    print("値12は見つかりませんでした")
```
{% endcode %}

### 10.4 フローチャートと疑似コード

#### 二分探索のフローチャート

二分探索のアルゴリズムをフローチャートで表現すると、以下のようになります。

```
開始
  ↓
[left = 0, right = リストの長さ - 1 で初期化]
  ↓
< left <= right ? > ---> NO ---> [「見つからなかった」を返す]
  | YES                            ↓
  ↓                              終了
[mid = (left + right) ÷ 2 を計算]
  ↓
[リスト[mid]と探索値を比較]
  ↓
< リスト[mid] == 探索値 ? > ---> YES ---> [mid を返す]
  | NO                                       ↓
  ↓                                        終了
< リスト[mid] > 探索値 ? > ---> YES ---> [right = mid - 1 に更新]
  | NO                                     ↓
  ↓                                    (ループの先頭に戻る)
[left = mid + 1 に更新]
  |
  +---> (ループの先頭に戻る)
```

#### 二分探索の疑似コード

二分探索のアルゴリズムを、特定のプログラミング言語に依存しない「疑似コード」で表現すると以下のようになります。

```
function binary_search(ソート済みリスト, 探索値):
    // 1. 探索範囲を初期化
    left = 0
    right = リストの長さ - 1
    
    // 2. 探索範囲がある限り繰り返す
    while left <= right:
        // 3. 中央のインデックスを計算
        mid = (left + right) ÷ 2
        
        // 4. 中央の要素と探索値を比較
        if ソート済みリスト[mid] == 探索値:
            // 5. 等しければ、そのインデックスを返して終了
            return mid
            
        // 6. 中央の要素が探索値より大きい場合、左半分を探索
        if ソート済みリスト[mid] > 探索値:
            right = mid - 1
            
        // 7. 中央の要素が探索値より小さい場合、右半分を探索
        else:
            left = mid + 1
            
    // 8. 探索範囲がなくなった場合は見つからなかったことを示す値を返す
    return -1
```

### 10.5 二分探索の特徴

#### メリット

* 非常に効率的な探索方法  \
  データ量が増えても、必要な比較回数はわずかしか増えません。例えば、100万個の要素があっても、最大で約20回の比較で結果が得られます。
* 大規模データに最適  \
  大量のデータを扱う場合に、線形探索に比べて桁違いに高速です。
* 探索範囲が指数関数的に減少  \
  各ステップで探索範囲が半分になるため、探索効率が非常に高いです。
* 予測可能なパフォーマンス  \
  最悪の場合でも、log₂(n)回の比較で結果が得られます。これを「O(log n)」（オーダー・ログ・エヌ）と表現します。

#### デメリット

* データがソートされている必要がある  \
  ソートされていないデータに対しては使用できません。先にソートする必要があります。
* ソートするコストも考慮が必要  \
  ソートされていないデータに対して二分探索を適用するには、まずソートする必要があり、そのコストも考慮すべきです。
* ランダムアクセスが可能なデータ構造のみ  \
  配列やリストのように、任意の位置にすぐにアクセスできるデータ構造でないと効率的に利用できません。連結リストには適していません。
* 実装が線形探索より複雑  \
  条件判断や境界処理などが複雑になりがちで、バグを生みやすい傾向があります。

#### データサイズによる影響

以下の表は、線形探索と二分探索の比較回数の違いを示しています。

| データサイズ    | 線形探索 (最悪)  | 二分探索 (最悪) |
| --------- | ---------- | --------- |
| 10        | 10回        | 約4回       |
| 100       | 100回       | 約7回       |
| 1,000     | 1,000回     | 約10回      |
| 1,000,000 | 1,000,000回 | 約20回      |

#### 二分探索の使い所

以下の状況では、二分探索が適しているか、選択肢の一つとなります。

* データがすでにソートされている場合
* 大規模なデータセット（要素数が多い）を扱う場合
* 同じデータセットに対して複数回の探索を行う場合
* 探索処理の速度が重要である場合
* ランダムアクセスが可能なデータ構造（配列やリストなど）を使用している場合

### 10.6 よくあるエラーと注意点

#### ソートされていないデータに適用&#xD;

二分探索はソートされていないデータには適用できません。必ずソートされたデータに対して使ってください。

```python
# 間違い
unsorted_list = [5, 2, 8, 1, 9, 3]
result = binary_search(unsorted_list, 3)  # 誤った結果を返す可能性がある

# 正しい
sorted_list = sorted(unsorted_list)  # まずソートする
result = binary_search(sorted_list, 3)
```

#### インデックス計算の間違い&#xD;

中央のインデックスを計算する際、整数除算を使わないと小数点以下が出てエラーになります。

```python
# 間違い
mid = (left + right) / 2  # 浮動小数点数になる

# 正しい
mid = (left + right) // 2  # 整数除算で整数値を得る
```

#### 境界条件の扱いミス&#xD;

探索範囲が1つの要素になったときに正しく処理できるよう、条件式を適切に設定する必要があります。

```python
# 間違い
while left < right:  # 範囲が1つの要素だけになると終了してしまう
    # ...

# 正しい
while left <= right:  # 範囲が1つの要素でも継続
    # ...
```

#### 無限ループに陥る&#xD;

探索範囲の更新を正しく行わないと、無限ループに陥る可能性があります。

```python
# 間違い
while left <= right:
    mid = (left + right) // 2
    if sorted_list[mid] < target:
        left = mid  # midをleftに代入すると、leftが進まない可能性がある
    # ...

# 正しい
while left <= right:
    mid = (left + right) // 2
    if sorted_list[mid] < target:
        left = mid + 1  # 必ず進める
    # ...
```

#### オーバーフローの問題（非常に大きな配列の場合）&#xD;

左右の境界が非常に大きい数値の場合、その和がオーバーフローする可能性があります。

```python
# 潜在的な問題（非常に大きな配列の場合）
mid = (left + right) // 2

# より安全な方法
mid = left + (right - left) // 2
```



## 演習問題

#### 問題 10-1: 二分探索のアルゴリズムの仕組みを段階的に理解しするための演習問題です。これらのステップは最終的に一つの関数にまとめることで、より実用的なコードになります。

**ステップ 1: 探索範囲の設定と中央値の確認**

二分探索の最初のステップは、探索範囲の左端と右端を設定し、中央の要素を確認することです。

```python
# ソート済みリストとターゲット値
sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 11

# 探索範囲の初期設定
left = 0
right = len(sorted_numbers) - 1

# 1. 探索範囲の中央のインデックスを計算し、中央の要素を表示する


```

<details>

<summary>ヒント</summary>

* 中央のインデックスは左端と右端のインデックスの平均で計算します: `mid = (left + right) // 2`

- 整数除算 `//` を使うことで、小数点以下が切り捨てられて整数のインデックスが得られます

* 中央の要素は `sorted_numbers[mid]` でアクセスできます

</details>

**ステップ2: ターゲット値と中央値の比較**

中央の要素とターゲット値を比較し、一致するか、大きいか、小さいかを判断します。

```python
# ソート済みリストとターゲット値
sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 11

# 探索範囲の初期設定
left = 0
right = len(sorted_numbers) - 1
mid = (left + right) // 2

# 2. 中央の要素とターゲット値を比較し、
# 一致するか、大きいか、小さいかを表示する


```

<details>

<summary>ヒント</summary>

* `if sorted_numbers[mid] == target:` で一致するかをチェックします

- `elif sorted_numbers[mid] > target:` でターゲットより大きいかをチェックします

* `else:` でそれ以外 (ターゲットより小さい) を処理します

- それぞれの場合に応じたメッセージを表示しましょう

</details>

**ステップ 3: 探索範囲の更新**

比較結果に基づいて、探索範囲を更新します。

```python
# ソート済みリストとターゲット値
sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 11

# 探索範囲の初期設定
left = 0
right = len(sorted_numbers) - 1
mid = (left + right) // 2

# 3. 中央の要素とターゲット値を比較し、
# 比較結果に基づいて探索範囲 (left, right) を更新する


# 更新後の探索範囲を表示
print(f"更新後の探索範囲: left={left}, right={right}")
```

<details>

<summary>ヒント</summary>

* 一致する場合は、探索終了 (このステップでは更新不要)

- ターゲットより大きい場合は、左半分を探索するために右端を更新: `right = mid - 1`

* ターゲットより小さい場合は、右半分を探索するために左端を更新: `left = mid + 1`

- これにより、探索範囲が半分に絞り込まれます

</details>

**ステップ 4: 探索の繰り返し - 値が見つかるか範囲がなくなるまで**

二分探索では、値が見つかるか探索範囲がなくなるまで、ステップ 2.と.3 を繰り返します。

```python
# ソート済みリストとターゲット値
sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 11

# 探索範囲の初期設定
left = 0
right = len(sorted_numbers) - 1

# 初期値として「見つからなかった」ことを示す値を設定
found_index = -1

# 4. 探索範囲がある限り、中央値の計算、比較、範囲の更新を繰り返す
# whileループを使う


# 結果の表示
if found_index != -1:
    print(f"値{target}はインデックス{found_index}の位置にあります")
else:
    print(f"値{target}は見つかりませんでした")
```

<details>

<summary>ヒント</summary>

* `while left <= right:` で探索範囲がある限り繰り返します

- ループ内で中央のインデックスを計算し、ターゲットと比較します

* 一致したらそのインデックスを記録し、ループを終了します

- 一致しない場合は、比較結果に基づいて探索範囲を更新します

</details>

**ステップ5: 関数化 - 二分探索を関数にまとめる**

ここまでのステップで学んだ二分探索のロジックを、再利用可能な関数にまとめましょう。

```python
def binary_search(sorted_list, target):
    """
    二分探索でソート済みリスト内の要素を探す
    
    引数:
    sorted_list -- 探索対象のソート済みリスト
    target -- 探している値
    
    戻り値:
    見つかった場合はインデックス、見つからなかった場合は -1
    """
    # 5. ステップ 1 から 4 までの処理をまとめて関数を完成させる
    # return を使って結果を返します

    
# 関数をテストする
sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target_value = 11

result = binary_search(sorted_numbers, target_value)
if result != -1:
    print(f"値{target_value}はインデックス{result}の位置にあります")
else:
    print(f"値{target_value}は見つかりませんでした")
```

<details>

<summary>ヒント</summary>

* 関数内では、探索範囲の初期設定から始めます

- ループ内で一致した場合は直接 `return mid` でインデックスを返します

* ループ終了後 (見つからなかった場合) は `-1` を返します

- 関数化することで、異なるソート済みリストやターゲット値でも再利用できるようになります

</details>



#### 問題 10-2: 線形探索と二分探索の効率比較

ソート済みリストに対して、線形探索と二分探索の比較回数を数えて効率を比較するプログラムを作成してください。

```python
# ソート済みリスト
sorted_numbers = list(range(1, 1001))  # 1 から 1000 までの数字

# 探したい値：リストの最後の要素
target = 1000

# 1. 線形探索の比較回数を数える
# ヒント: 値を比較するたびにカウンターを増やす


# 2. 二分探索の比較回数を数える


# 3. 結果を表示する


```

<details>

<summary>ヒント</summary>

* 比較回数を数えるためのカウンター変数を用意します

- 値を比較するたびにカウンターを増やします

* 最後の要素を探す場合、線形探索では最悪のケース（全要素の比較）となります

- 二分探索では、最悪でもリストの長さの対数（約log₂(n)）の比較回数で済みます

</details>
