# 二分探索

### 探索問題とは

探索問題とは、データの集合 (リストなど) の中から、特定の条件を満たす要素を見つけ出す問題のことです。

* 日常生活の例
  * 本棚から特定の本を探す
  * 辞書から特定の単語を探す
  * スマートフォンの連絡先から特定の人の番号を探す
* プログラミングでの重要性
  * データベースからの情報検索
  * 配列やリスト内の要素検索
  * ファイル内のテキスト検索

### 日常生活での二分探索の例

#### 例：辞書から特定の単語を探す

辞書から特定の単語を探す方法は、二分探索の典型的な例です。

* 辞書はアルファベット順（50音順）にソートされている
* 辞書の真ん中あたりを開く
* 探している単語が開いたページよりも前にあるか後ろにあるかを判断
* それに応じて、前半部分または後半部分だけを探索
* 対象の範囲を半分に絞りながら、同じ手順を繰り返す

この「辞書での単語探し」の手順を自然言語で表現すると、

```
# 辞書での単語探しの基本的な流れ
1. 辞書の範囲（最初のページから最後のページまで）を設定

2. 探索範囲がある限り:
   a. 現在の範囲の真ん中のページを開く
   b. そのページの単語を確認する
   c. もし探している単語と同じなら:
      「見つかりました！」と報告して終了
   d. もし探している単語がそのページより前にあるなら:
      後半部分を除外して前半部分だけを新しい範囲として手順2に戻る
   e. もし探している単語がそのページより後ろにあるなら:
      前半部分を除外して後半部分だけを新しい範囲として手順2に戻る

3. 探索範囲がなくなったら:
   「見つかりませんでした」と報告
```

この方法は、ページを1ページずつめくる方法（線形探索）と比べて、大幅に効率的です。

### 二分探索のアルゴリズム

#### 基本的な考え方

二分探索（バイナリサーチとも呼ばれます）は、**ソートされたデータ**を対象とする高速な探索アルゴリズムです。

* 探索範囲の中央にある要素から探索を始める
* 中央の要素と探している値を比較し、探索範囲を半分に絞る
* 新しい探索範囲に対して同じ処理を繰り返す
* 探索範囲がなくなるか、値が見つかるまで続ける

#### Pythonによる実装

```python
def binary_search(sorted_list, target):
    """
    二分探索でソート済みリスト内の要素を探す
    
    引数:
    sorted_list -- 探索対象のソート済みリスト
    target -- 探している値
    
    戻り値:
    見つかった場合はインデックス、見つからなかった場合は-1
    """
    # 探索範囲の初期設定
    left = 0
    right = len(sorted_list) - 1
    
    # 探索範囲がある限り繰り返す
    while left <= right:
        # 中央のインデックスを計算
        mid = (left + right) // 2
        
        # 中央の要素が探している値と等しいか確認
        if sorted_list[mid] == target:
            return mid  # 見つかった場合、そのインデックスを返す
        
        # 中央の要素が探している値より大きい場合、左半分を探索
        elif sorted_list[mid] > target:
            right = mid - 1
        
        # 中央の要素が探している値より小さい場合、右半分を探索
        else:
            left = mid + 1
    
    # リスト内を全て探しても見つからなかった場合
    return -1
```

#### 二分探索の使用例

```python
# ソート済みの数値のリスト
numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]

# 値11を探す
result = binary_search(numbers, 11)

# 結果の表示
if result != -1:
    print(f"値11はインデックス{result}の位置にあります")
else:
    print("値11は見つかりませんでした")

# 値12を探す（リストにない値）
result = binary_search(numbers, 12)

# 結果の表示
if result != -1:
    print(f"値12はインデックス{result}の位置にあります")
else:
    print("値12は見つかりませんでした")
```

### リストを使った二分探索の図解

例えば、ソート済みリスト `[1, 3, 5, 7, 9, 11, 13]` の中から値 `9` を探す場合:

```
インデックス:  0  1  2  3  4   5   6
リスト:      [1, 3, 5, 7, 9, 11, 13]
                      ↑
                     中央
```

ステップ1: 探索範囲は \[0-6], 中央は3, リスト\[3] = 7 をチェック -> 7 < 9 -> 右半分を探索

```
インデックス:  0  1  2  3  4   5   6
リスト:      [1, 3, 5, 7, 9, 11, 13]
                          ↑
                         中央
```

ステップ2: 探索範囲は \[4-6], 中央は5, リスト\[5] = 11 をチェック -> 11 > 9 -> 左半分を探索

```
インデックス:  0  1  2  3  4   5   6
リスト:      [1, 3, 5, 7, 9, 11, 13]
                          ↑
                         中央
```

ステップ3: 探索範囲は \[4-4], 中央は4, リスト\[4] = 9 をチェック -> 9 == 9 -> 発見！インデックス4を返す

もし値が見つからない場合は、探索範囲がなくなるまで同様に進み、最終的に「見つからなかった」と判断します。

### フローチャートと疑似コード

#### 二分探索のフローチャート

二分探索のアルゴリズムをフローチャートで表現すると、以下のようになります。

```
開始
  ↓
[left = 0, right = リストの長さ - 1 で初期化]
  ↓
< left <= right ? > ---> NO ---> [「見つからなかった」を返す]
  | YES                            ↓
  ↓                              終了
[mid = (left + right) ÷ 2 を計算]
  ↓
[リスト[mid]と探索値を比較]
  ↓
< リスト[mid] == 探索値 ? > ---> YES ---> [mid を返す]
  | NO                                       ↓
  ↓                                        終了
< リスト[mid] > 探索値 ? > ---> YES ---> [right = mid - 1 に更新]
  | NO                                     ↓
  ↓                                    (ループの先頭に戻る)
[left = mid + 1 に更新]
  |
  +---> (ループの先頭に戻る)
```

#### 二分探索の疑似コード

二分探索のアルゴリズムを、特定のプログラミング言語に依存しない「疑似コード」で表現すると以下のようになります。

```
function binary_search(ソート済みリスト, 探索値):
    // 1. 探索範囲を初期化
    left = 0
    right = リストの長さ - 1
    
    // 2. 探索範囲がある限り繰り返す
    while left <= right:
        // 3. 中央のインデックスを計算
        mid = (left + right) ÷ 2
        
        // 4. 中央の要素と探索値を比較
        if ソート済みリスト[mid] == 探索値:
            // 5. 等しければ、そのインデックスを返して終了
            return mid
            
        // 6. 中央の要素が探索値より大きい場合、左半分を探索
        if ソート済みリスト[mid] > 探索値:
            right = mid - 1
            
        // 7. 中央の要素が探索値より小さい場合、右半分を探索
        else:
            left = mid + 1
            
    // 8. 探索範囲がなくなった場合は見つからなかったことを示す値を返す
    return -1
```

### 二分探索の特徴

#### メリット

* 非常に効率的な探索方法  \
  データ量が増えても、必要な比較回数はわずかしか増えません。例えば、100万個の要素があっても、最大で約20回の比較で結果が得られます。
* 大規模データに最適  \
  大量のデータを扱う場合に、線形探索に比べて桁違いに高速です。
* 探索範囲が指数関数的に減少  \
  各ステップで探索範囲が半分になるため、探索効率が非常に高いです。
* 予測可能なパフォーマンス  \
  最悪の場合でも、log₂(n)回の比較で結果が得られます。これを「O(log n)」（オーダー・ログ・エヌ）と表現します。

#### デメリット

* データがソートされている必要がある  \
  ソートされていないデータに対しては使用できません。先にソートする必要があります。
* ソートするコストも考慮が必要  \
  ソートされていないデータに対して二分探索を適用するには、まずソートする必要があり、そのコストも考慮すべきです。
* ランダムアクセスが可能なデータ構造のみ  \
  配列やリストのように、任意の位置にすぐにアクセスできるデータ構造でないと効率的に利用できません。連結リストには適していません。
* 実装が線形探索より複雑  \
  条件判断や境界処理などが複雑になりがちで、バグを生みやすい傾向があります。

#### データサイズによる影響

以下の表は、線形探索と二分探索の比較回数の違いを示しています。

| データサイズ    | 線形探索 (最悪)  | 二分探索 (最悪) |
| --------- | ---------- | --------- |
| 10        | 10回        | 約4回       |
| 100       | 100回       | 約7回       |
| 1,000     | 1,000回     | 約10回      |
| 1,000,000 | 1,000,000回 | 約20回      |

#### 二分探索の使い所

以下の状況では、二分探索が適しているか、選択肢の一つとなります。

* データがすでにソートされている場合
* 大規模なデータセット（要素数が多い）を扱う場合
* 同じデータセットに対して複数回の探索を行う場合
* 探索処理の速度が重要である場合
* ランダムアクセスが可能なデータ構造（配列やリストなど）を使用している場合

### よくあるエラーと注意点

*   ソートされていないデータに適用    \
    二分探索はソートされていないデータには適用できません。必ずソートされたデータに対して使ってください。

    ```python
    # 間違い
    unsorted_list = [5, 2, 8, 1, 9, 3]
    result = binary_search(unsorted_list, 3)  # 誤った結果を返す可能性がある

    # 正しい
    sorted_list = sorted(unsorted_list)  # まずソートする
    result = binary_search(sorted_list, 3)
    ```
*   インデックス計算の間違い    \
    中央のインデックスを計算する際、整数除算を使わないと小数点以下が出てエラーになります。

    ```python
    # 間違い
    mid = (left + right) / 2  # 浮動小数点数になる

    # 正しい
    mid = (left + right) // 2  # 整数除算で整数値を得る
    ```
*   境界条件の扱いミス    \
    探索範囲が1つの要素になったときに正しく処理できるよう、条件式を適切に設定する必要があります。

    ```python
    # 間違い
    while left < right:  # 範囲が1つの要素だけになると終了してしまう
        # ...

    # 正しい
    while left <= right:  # 範囲が1つの要素でも継続
        # ...
    ```
*   無限ループに陥る    \
    探索範囲の更新を正しく行わないと、無限ループに陥る可能性があります。

    ```python
    # 間違い
    while left <= right:
        mid = (left + right) // 2
        if sorted_list[mid] < target:
            left = mid  # midをleftに代入すると、leftが進まない可能性がある
        # ...

    # 正しい
    while left <= right:
        mid = (left + right) // 2
        if sorted_list[mid] < target:
            left = mid + 1  # 必ず進める
        # ...
    ```
*   オーバーフローの問題（非常に大きな配列の場合）    \
    左右の境界が非常に大きい数値の場合、その和がオーバーフローする可能性があります。

    ```python
    # 潜在的な問題（非常に大きな配列の場合）
    mid = (left + right) // 2

    # より安全な方法
    mid = left + (right - left) // 2
    ```
