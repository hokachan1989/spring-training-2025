# 線形探索

### 探索問題とは

探索問題とは、データの集合 (リストなど) の中から、特定の条件を満たす要素を見つけ出す問題のことです。

* 日常生活の例
  * 本棚から特定の本を探す
  * 辞書から特定の単語を探す
  * スマートフォンの連絡先から特定の人の番号を探す
* プログラミングでの重要性
  * データベースからの情報検索
  * 配列やリスト内の要素検索
  * ファイル内のテキスト検索

### 日常生活での線形探索の例

#### 例：本棚から特定の本を探す

本棚から特定の本を探す方法は、線形探索の典型的な例です。

* 本棚の左端 (または右端) から探し始める
* 一冊ずつ本のタイトルを確認していく
* 探している本が見つかったら、そこで探索を終了する
* 本棚全体を確認しても見つからなければ 「その本はない」 と判断する

この 「本探し」 の手順を自然言語で表現すると、

```
# 本探しの基本的な流れ
1. 本棚の左端から探し始める

2. まだ確認していない本があるなら:
   a. 今見ている本のタイトルを確認する
   b. もし探しているタイトルと同じなら:
      「見つかりました！」と報告して終了
   c. もし違うなら:
      次の本に移動して手順2に戻る

3. すべての本を確認しても見つからなかったら:
   「見つかりませんでした」と報告
```

### 線形探索のアルゴリズム

{% embed url="https://hokachan1989.github.io/spring-training-2025/lenear_search.html" %}

#### 基本的な考え方

線形探索 (リニアサーチとも呼ばれます) は、最もシンプルで直感的な探索アルゴリズムです。

* リストの先頭から順番に各要素を調べていく
* リストの中に探している値が見つかったら、その**位置 (インデックス)** を返す
* リストの最後まで探しても見つからなかった場合は、「見つからなかった」ことを示す値 (Pythonでは慣習的に -1) を返す

#### Pythonによる実装

```python
def linear_search(data_list, target):
    """
    線形探索でリスト内の要素を探す
    
    引数:
    data_list -- 探索対象のリスト
    target -- 探している値
    
    戻り値:
    見つかった場合はインデックス、見つからなかった場合は-1
    """
    # リストの各要素を先頭から順番にチェック
    for i in range(len(data_list)):
        # 現在の要素が探している値と等しいか確認
        if data_list[i] == target:
            return i  # 見つかった場合、そのインデックスを返す
    
    # リスト内を全て探しても見つからなかった場合
    return -1
```

#### 線形探索の使用例

```python
# 数値のリスト
numbers = [5, 2, 8, 4, 9, 3, 7]

# 探したい値（ターゲット）
target = 7

# 線形探索を実行
result = linear_search(numbers, target)

# 結果の表示
if result != -1:
    print(f"値{target}はインデックス{result}の位置にあります")
else:
    print(f"値{target}は見つかりませんでした")
```

### フローチャートと疑似コード

#### 線形探索のフローチャート

線形探索のアルゴリズムをフローチャートで表現すると、以下のようになります。

```
開始
  ↓
[インデックス = 0で初期化]
  ↓
< インデックス < リストの長さ ? > ---> NO ---> [「見つからなかった」を返す]
  | YES                                           ↓
  ↓                                             終了
[現在の要素が探索値と等しいか確認]
  | 
  ↓
< 等しい ? > ---> YES ---> [現在のインデックスを返す]
  | NO                       ↓
  ↓                        終了
[インデックスを1増やす]
  |
  +---> (ループの先頭に戻る)
```

#### 線形探索の疑似コード

線形探索のアルゴリズムを、特定のプログラミング言語に依存しない「疑似コード」で表現すると以下のようになります。

```
function linear_search(リスト, 探索値):
    // 1. リストの先頭（インデックス0）から始める
    インデックス = 0

    // 2. リストの最後まで繰り返す (インデックスがリストの長さ未満の間)
    while (インデックス < リストの長さ):
        // 3. 現在の要素 (リスト[インデックス]) が探索値と等しいか比較する
        if リスト[インデックス] == 探索値:
            // 4. 等しければ、現在のインデックスを返して終了
            return インデックス

        // 5. 等しくなければ、次の要素を見るためにインデックスを1増やす
        インデックス = インデックス + 1

    // 6. ループが終了した場合（＝リストの最後まで見つからなかった場合）
    //    「見つからなかった」ことを示す値を返す
    return -1
```

### 線形探索の特徴

#### メリット

* シンプルで実装が容易  \
  アルゴリズムの考え方が単純で、コードも短く書けます。
* 事前にデータを整列（ソート）する必要がない  \
  データがソート（整列）されている必要がありません。どんな順番のデータに対しても使えます。
* 小さなデータセットでは十分実用的  \
  要素数が少ない場合は、処理時間も短く済みます。
* どんなデータでも適用できる汎用性  \
  数値、文字列、その他のオブジェクトなど、様々な種類のデータに対して適用できます。
* 連続していないデータ構造（連結リストなど）でも使用可能  \
  配列のようにインデックスで直接アクセスできないデータ構造（例: 連結リスト）でも使えます。

#### デメリット

* 大きなデータセットでは効率が悪い:  \
  線形探索はデータ量が多くなると、探索に時間がかかるようになります。
* 最悪の場合、すべての要素を調べる必要がある:  \
  探している要素がリストの最後にある場合や、リスト内に存在しない場合、リストの全要素を確認する必要があります。  \
  補足: このように、処理時間がデータ量 N に比例して増加する性質を、計算量の分野では O(N)（オーダー N）と表現することがあります。

#### 線形探索の使い所

以下の状況では、線形探索が適しているか、選択肢の一つとなります。

* データセットが小さい (要素数が少ない) 場合
* 探索を行う回数が非常に少ない場合
* データがソートされていない、またはソートするコストが高い場合
* 探しているアイテムがリストの先頭付近にある可能性が高いと予想される場合
* 連結リストのように、要素へのランダムアクセス (インデックス指定でのアクセス) が効率的でないデータ構造の場合

### よくあるエラーと注意点

*   **インデックスの範囲外アクセス**

    ```python
    # 間違い
    while i <= len(data_list):  # 不適切な条件：「<=」を使っている
        # 最後のインデックスで範囲外エラーが発生

    # 正しい
    while i < len(data_list):  # 適切な条件：「<」を使う
    ```
*   **比較演算子の間違い**

    ```python
    # 間違い
    if data_list[i] = target:  # 代入演算子を使っている

    # 正しい
    if data_list[i] == target:  # 比較演算子を使う
    ```
*   **無限ループ**

    ```python
    # 間違い
    while i < len(data_list):
        if data_list[i] == target:
            return i
        # カウンタのインクリメントを忘れている

    # 正しい
    while i < len(data_list):
        if data_list[i] == target:
            return i
        i += 1  # カウンタをインクリメント
    ```
*   **探索の早期終了を忘れる**

    ```python
    # 非効率
    found_index = -1
    for i in range(len(data_list)):
        if data_list[i] == target:
            found_index = i
    return found_index  # リストの最後まで常に探索する

    # 効率的
    for i in range(len(data_list)):
        if data_list[i] == target:
            return i  # 見つかった時点で即座に返す
    return -1
    ```
* **重複要素への対応**
  * 標準的な線形探索は最初に見つかった要素のインデックスのみを返します
  * 複数の一致を見つけたい場合は、見つかったすべてのインデックスを配列で返すよう実装を変更する必要があります
