# 挿入ソート

### ソート問題とは

ソート問題とは、データの集合（リストなど）を特定の順序（昇順や降順）に並べ替える問題のことです。

* 日常生活の例
  * トランプのカードを数字順に並べる
  * 図書館の本を著者名のアルファベット順に整理する
  * 学生の名簿を五十音順に並び替える
* プログラミングでの重要性
  * データの検索効率の向上（二分探索などの効率的なアルゴリズムが使用可能になる）
  * データの視覚的な理解のしやすさ
  * データ処理や分析の前処理として重要
  * 重複データの特定が容易になる

### 日常生活での挿入ソートの例

#### 例：手持ちのトランプカードの整理

トランプをプレイしながら手に入れたカードを整理する方法は、挿入ソートの典型的な例です。

* 最初に1枚目のカードを「整列済み」とする
* 次のカードを取り、既に整列済みのカードと比較する
* そのカードが入るべき正しい位置を見つけ、そこにカードを「挿入」する
* これを繰り返し、すべてのカードが正しい順序で並ぶまで続ける

この「トランプカードの整理」の手順を自然言語で表現すると、

```
# 手持ちトランプの整理の基本的な流れ
1. 最初のカードは既にソート済みとみなす

2. 未整理のカード（2枚目以降）について1枚ずつ:
   a. そのカードを手に取る
   b. そのカードよりも値が大きいソート済みのカードを右にずらして隙間を作る
   c. 適切な位置（隙間）にカードを挿入する

3. すべてのカードが整理されたら完了
```

この方法は、新しいカードが手に入るたびに、すでに整理されている手札の適切な位置に挿入するため、常に手札が整列された状態を保つことができます。

### 挿入ソートのアルゴリズム

#### 基本的な考え方

挿入ソート（Insertion Sort）は、整列済みの部分と未整列の部分に分けて考えるソートアルゴリズムです。

* リストを「ソート済み部分」と「未ソート部分」に分ける（最初は先頭の要素のみがソート済み）
* 未ソート部分の先頭から要素を1つ取り出す
* ソート済み部分の中で、その要素が入るべき正しい位置を見つける
* ソート済み部分の要素を必要に応じて右にずらし、空いた位置に取り出した要素を挿入する
* ソート済み部分が1つ増え、未ソート部分が1つ減る
* 未ソート部分がなくなるまで繰り返す

#### Pythonによる実装

```python
def insertion_sort(arr):
    """
    挿入ソートでリストを昇順に並べ替える
    
    引数:
    arr -- ソート対象のリスト
    
    戻り値:
    なし（リストは参照渡しのため、元のリストが変更される）
    """
    # 配列の先頭はソート済みとみなし、2番目の要素から開始
    for i in range(1, len(arr)):
        # 現在の要素を取り出し、挿入先を探すためのキー値とする
        key = arr[i]
        
        # ソート済み部分において、キー値の挿入位置を探す
        # keyより大きい要素は右に1つずつずらす
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # 要素を右にずらす
            j -= 1
            
        # 適切な位置にキー値を挿入
        arr[j + 1] = key
```

#### 挿入ソートの使用例

```python
# 数値のリスト
numbers = [12, 11, 13, 5, 6]
print(f"ソート前: {numbers}")

# 挿入ソートを実行
insertion_sort(numbers)

# 結果の表示
print(f"ソート後: {numbers}")  # 出力: [5, 6, 11, 12, 13]
```

### 挿入ソートのステップごとの図解

例えば、リスト `[12, 11, 13, 5, 6]` をソートする過程を示します：

**初期状態**:

```
[12, 11, 13, 5, 6]
 ↑   未ソート部分   
ソート済み
```

**ステップ1**: 2番目の要素（11）を適切な位置に挿入

```
[12, 11, 13, 5, 6]  - 11を取り出す
[12, _, 13, 5, 6]   - 12と比較して小さいので、12を右にずらす
[11, 12, 13, 5, 6]  - 11を適切な位置に挿入
 ↑   ↑  未ソート部分
 ソート済み
```

**ステップ2**: 3番目の要素（13）を適切な位置に挿入

```
[11, 12, 13, 5, 6]  - 13を取り出す
              ↑
[11, 12, 13, 5, 6]  - 12より大きいため、そのままでOK
 ↑   ↑   ↑  未ソート
 ソート済み部分
```

**ステップ3**: 4番目の要素（5）を適切な位置に挿入

```
[11, 12, 13, 5, 6]  - 5を取り出す
[11, 12, 13, _, 6]  - 13と比較して小さいので、13を右にずらす
[11, 12, _, 13, 6]  - 12と比較して小さいので、12を右にずらす
[11, _, 12, 13, 6]  - 11と比較して小さいので、11を右にずらす
[5, 11, 12, 13, 6]  - 5を適切な位置に挿入
 ↑   ↑   ↑   ↑  未ソート
 ソート済み部分
```

**ステップ4**: 5番目の要素（6）を適切な位置に挿入

```
[5, 11, 12, 13, 6]  - 6を取り出す
[5, 11, 12, 13, _]  - 13と比較して小さいので、13を右にずらす
[5, 11, 12, _, 13]  - 12と比較して小さいので、12を右にずらす
[5, 11, _, 12, 13]  - 11と比較して小さいので、11を右にずらす
[5, _, 11, 12, 13]  - 5と比較して大きいので、5の右に挿入
[5, 6, 11, 12, 13]  - 6を適切な位置に挿入
 ↑   ↑   ↑   ↑   ↑
    ソート完了
```

### フローチャートと疑似コード

#### 挿入ソートのフローチャート

挿入ソートのアルゴリズムをフローチャートで表現すると、以下のようになります。

```
開始
  ↓
[i = 1で初期化（ソート開始位置）]
  ↓
< i < 配列の長さ ? > ---> NO ---> [ソート完了]
  | YES                            ↓
  ↓                              終了
[key = arr[i] で現在の要素を保存]
  ↓
[j = i - 1 で初期化（ソート済み部分の末尾）]
  ↓
< j >= 0 かつ arr[j] > key ? > ---> NO ---> [arr[j+1] = key で要素を挿入]
  | YES                                       ↓
  ↓                                        [i = i + 1]
[arr[j+1] = arr[j] で要素を右にずらす]        ↓
  ↓                                    (iのループの先頭に戻る)
[j = j - 1]
  |
  +---> (jのループの先頭に戻る)
```

#### 挿入ソートの疑似コード

挿入ソートのアルゴリズムを、特定のプログラミング言語に依存しない「疑似コード」で表現すると以下のようになります。

```
procedure insertion_sort(arr):
    // 配列の2番目の要素からソート開始
    for i from 1 to length(arr)-1:
        // 現在の要素をキーとして保存
        key = arr[i]
        
        // ソート済み部分で正しい挿入位置を探す
        j = i - 1
        while j >= 0 and arr[j] > key:
            // keyより大きい要素を右にずらす
            arr[j+1] = arr[j]
            j = j - 1
        
        // 適切な位置にキーを挿入
        arr[j+1] = key
```

### 挿入ソートの特徴

#### メリット

* 実装がシンプル  \
  アルゴリズムの考え方が直感的で、比較的少ないコードで実装できます。
* 小さなデータセットで効率的  \
  要素数が少ない場合は非常に効率的で、選択ソートよりも優れたパフォーマンスを示すことが多いです。
* 安定ソート  \
  同じ値を持つ要素の相対的な順序が保持されます（安定ソート）。
* 部分的にソート済みのデータに強い  \
  既にある程度ソートされているデータに対しては、非常に効率的に動作します。
* オンラインアルゴリズム  \
  全データを最初に揃える必要がなく、データが来るたびに逐次的にソートできます。

#### デメリット

* 大きなデータセットでは非効率  \
  時間計算量はO(n²)で、データ量が増えると急激に処理時間が増加します。
* 逆順に近いデータでの性能が悪い  \
  ほぼ逆順にソートされているデータに対しては、最悪のパフォーマンスを示します。
* 他の高度なアルゴリズムと比較して遅い  \
  クイックソート、マージソート、ヒープソートなどと比較すると、大規模データでは効率が劣ります。

#### 計算量

* **時間計算量**:
  * 最良の場合: O(n) - データが既にソートされている場合
  * 平均的な場合: O(n²)
  * 最悪の場合: O(n²) - データが逆順にソートされている場合
* **空間計算量**: O(1) - 追加のメモリをほとんど使用しません

#### 挿入ソートの使い所

以下の状況では、挿入ソートが適しているか、選択肢の一つとなります。

* 小さなデータセット（要素数が少ない）の場合
* データがすでに部分的にソートされている場合
* オンラインでデータを処理する必要がある場合（データが逐次的に到着する）
* 安定ソートが必要な場合
* メモリ使用量を最小限に抑えたい場合
* シンプルな実装が好ましい場合

### よくあるエラーと注意点

*   **ループの初期値設定ミス**

    ```python
    # 間違い
    for i in range(len(arr)):  # 0から始めると最初の要素を比較する対象がない

    # 正しい
    for i in range(1, len(arr)):  # 1から始める（最初の要素はソート済みとみなす）
    ```
*   **比較と代入の順序ミス**

    ```python
    # 間違い
    while j >= 0:  # キー値との比較が欠けている
        arr[j + 1] = arr[j]
        j -= 1

    # 正しい
    while j >= 0 and arr[j] > key:  # 条件を正しく設定
        arr[j + 1] = arr[j]
        j -= 1
    ```
*   **境界条件の考慮不足**

    ```python
    # 間違い
    while j > 0 and arr[j-1] > key:  # j=0の場合に問題が発生

    # 正しい
    while j >= 0 and arr[j] > key:  # j=0の場合も適切に処理
    ```
*   **キー値の上書き**

    ```python
    # 間違い - keyを保存せずに直接操作
    for i in range(1, len(arr)):
        j = i - 1
        while j >= 0 and arr[j] > arr[i]:  # arr[i]が右シフト操作で上書きされる
            arr[j + 1] = arr[j]
            j -= 1

    # 正しい - keyに保存してから操作
    for i in range(1, len(arr)):
        key = arr[i]  # 現在の要素を保存
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    ```
*   **挿入位置の計算ミス**

    ```python
    # 間違い
    arr[j] = key  # jは最後のwhile条件で-1されている可能性がある

    # 正しい
    arr[j + 1] = key  # 必ず正しい位置に挿入
    ```
