# 選択ソート

### ソート問題とは

ソート問題とは、データの集合（リストなど）を特定の順序（昇順や降順）に並べ替える問題のことです。

* 日常生活の例
  * トランプのカードを数字順に並べる
  * 図書館の本を著者名のアルファベット順に整理する
  * 学生の名簿を五十音順に並び替える
* プログラミングでの重要性
  * データの検索効率の向上（二分探索などの効率的なアルゴリズムが使用可能になる）
  * データの視覚的な理解のしやすさ
  * データ処理や分析の前処理として重要
  * 重複データの特定が容易になる

### 日常生活での選択ソートの例

#### 例：トランプカードの整理

手元にあるトランプカードを数字の小さい順に並べる方法は、選択ソートの典型的な例です。

* まず全てのカードを確認し、最も小さい数字のカードを見つける
* そのカードを一番左側（または別の山）に置く
* 残りのカードの中から、また最も小さい数字のカードを見つける
* そのカードを先ほど選んだカードの右隣に置く
* これを繰り返し、全てのカードが順番に並ぶまで続ける

この「トランプカードの整理」の手順を自然言語で表現すると、

```
# トランプカードの整理の基本的な流れ
1. 未整理のカードの山を用意する

2. 未整理のカードがある限り:
   a. 未整理のカードの中から最小のカードを探す
   b. そのカードを取り出し、整理済みの山の右端に追加する
   c. 未整理のカードの数を1つ減らす

3. すべてのカードが整理済みの山に移ったら完了
```

### 選択ソートのアルゴリズム

#### 基本的な考え方

選択ソート（Selection Sort）は、シンプルなソートアルゴリズムで、以下のステップで動作します：

* リストを「ソート済み部分」と「未ソート部分」に分ける（最初はソート済み部分は空）
* 未ソート部分から最小値（または最大値）を見つける
* その最小値を未ソート部分の先頭と交換する（つまり、ソート済み部分の末尾に追加）
* ソート済み部分が1つ増え、未ソート部分が1つ減る
* 未ソート部分がなくなるまで繰り返す

#### Pythonによる実装

```python
def selection_sort(arr):
    """
    選択ソートでリストを昇順に並べ替える
    
    引数:
    arr -- ソート対象のリスト
    
    戻り値:
    なし（リストは参照渡しのため、元のリストが変更される）
    """
    n = len(arr)
    
    # リストの先頭から順に、その位置に来るべき最小値を見つけて配置する
    for i in range(n):
        # 現在の位置（i）以降の最小値のインデックスを見つける
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 見つけた最小値と現在の位置（i）の要素を交換
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```

#### 選択ソートの使用例

```python
# 数値のリスト
numbers = [64, 25, 12, 22, 11]
print(f"ソート前: {numbers}")

# 選択ソートを実行
selection_sort(numbers)

# 結果の表示
print(f"ソート後: {numbers}")  # 出力: [11, 12, 22, 25, 64]
```

### 選択ソートのステップごとの図解

例えば、リスト `[64, 25, 12, 22, 11]` をソートする過程を示します：

**初期状態**:

```
[64, 25, 12, 22, 11]
 ↑   未ソート部分   
現在位置
```

**ステップ1**: インデックス0に最小値を配置するため、リスト全体から最小値11（インデックス4）を見つけ、64と交換

```
[11, 25, 12, 22, 64]
 ↑   未ソート部分   
ソート済み
```

**ステップ2**: インデックス1に次の最小値を配置するため、残りのリストから最小値12（インデックス2）を見つけ、25と交換

```
[11, 12, 25, 22, 64]
 ↑   ↑  未ソート部分
 ソート済み
```

**ステップ3**: インデックス2に次の最小値を配置するため、残りのリストから最小値22（インデックス3）を見つけ、25と交換

```
[11, 12, 22, 25, 64]
 ↑   ↑   ↑  未ソート
 ソート済み部分
```

**ステップ4**: インデックス3に次の最小値を配置するため、残りのリストから最小値25（インデックス3）を見つける（既に正しい位置）

```
[11, 12, 22, 25, 64]
 ↑   ↑   ↑   ↑   ↑
    ソート完了
```

### フローチャートと疑似コード

#### 選択ソートのフローチャート

選択ソートのアルゴリズムをフローチャートで表現すると、以下のようになります。

```
開始
  ↓
[i = 0で初期化（現在のソート位置）]
  ↓
< i < 配列の長さ ? > ---> NO ---> [ソート完了]
  | YES                            ↓
  ↓                              終了
[min_idx = i で初期化（最小値の位置）]
  ↓
[j = i+1 で初期化（比較開始位置）]
  ↓
< j < 配列の長さ ? > ---> NO ---> [arr[i]とarr[min_idx]を交換]
  | YES                            ↓
  ↓                             [i = i + 1]
< arr[j] < arr[min_idx] ? >        ↓
  | YES            | NO         (iのループの先頭に戻る)
  ↓               ↓
[min_idx = j]   [次のjへ]
  |               |
  +-------+-------+
          ↓
      [j = j + 1]
          |
          +---> (jのループの先頭に戻る)
```

#### 選択ソートの疑似コード

選択ソートのアルゴリズムを、特定のプログラミング言語に依存しない「疑似コード」で表現すると以下のようになります。

```
procedure selection_sort(arr):
    n = length(arr)
    
    // 配列の先頭から順にソート
    for i from 0 to n-1:
        // 最小値のインデックスを初期化
        min_idx = i
        
        // 現在位置より後ろの最小値を探す
        for j from i+1 to n-1:
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        // 見つけた最小値と現在位置の要素を交換
        swap arr[i] and arr[min_idx]
```

### 選択ソートの特徴

#### メリット

* 実装がシンプル  \
  アルゴリズムの考え方が理解しやすく、少ないコードで実装できます。
* 安定なメモリ使用量  \
  追加のメモリ領域をほとんど必要とせず、元のリスト上で直接ソートができます（「インプレースソート」とも呼ばれます）。
* データの移動回数が少ない  \
  各要素の交換が最大でN回（Nはリストの長さ）だけで済みます。
* 入力データの状態に依存しない一定のパフォーマンス  \
  最良、平均、最悪の場合すべてで同じ時間がかかります（データが既にソートされていても全走査が必要）。

#### デメリット

* 大きなデータセットでは非効率  \
  時間計算量はO(n²)で、データ量が増えると急激に処理時間が増加します。
* 安定ソートではない  \
  同じ値の要素の相対的な順序が保証されません（実装によって変わります）。
* 他の高度なアルゴリズムと比較して遅い  \
  クイックソート、マージソート、ヒープソートなどと比較すると効率が劣ります。

#### 計算量

* **時間計算量**:
  * 最良の場合: O(n²) - データが既にソートされていても全走査が必要
  * 平均的な場合: O(n²)
  * 最悪の場合: O(n²)
* **空間計算量**: O(1) - 追加のメモリをほとんど使用しません

#### 選択ソートの使い所

以下の状況では、選択ソートが適しているか、選択肢の一つとなります。

* 小さなデータセット（要素数が少ない）の場合
* メモリ使用量を最小限に抑えたい場合
* シンプルで理解しやすいアルゴリズムが必要な場合
* 教育目的でソートアルゴリズムを学ぶ場合
* 要素の移動回数を最小限にしたい場合

### よくあるエラーと注意点

*   **配列のインデックス範囲のミス**

    ```python
    # 間違い
    for i in range(n+1):  # 範囲外アクセスの可能性

    # 正しい
    for i in range(n):  # n-1までのインデックスにアクセス
    ```
*   **交換の記述ミス**

    ```python
    # 間違い
    arr[i] = arr[min_idx]  # 一方的な代入では値が失われる
    arr[min_idx] = arr[i]

    # 正しい
    arr[i], arr[min_idx] = arr[min_idx], arr[i]  # 同時に交換
    ```
*   **最小値のインデックス初期化忘れ**

    ```python
    # 間違い
    for i in range(n):
        # min_idxの初期化を忘れている
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j

    # 正しい
    for i in range(n):
        min_idx = i  # 各ループでmin_idxを初期化
        for j in range(i+1, n):
    ```
*   **無駄な交換**

    ```python
    # 非効率
    arr[i], arr[min_idx] = arr[min_idx], arr[i]  # 常に交換

    # 効率的
    if min_idx != i:  # 必要な場合のみ交換
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    ```
* **安定性の誤解**
  * 選択ソートは基本的に安定ソートではありません（同じ値の要素の相対的な順序が変わる可能性がある）
  * 安定性が要求される場合は他のソートアルゴリズム（例：挿入ソート、マージソート）を検討してください
