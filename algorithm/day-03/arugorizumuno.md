# アルゴリズムの計算量

### 計算量とは何か？

「アルゴリズムの計算量」とは、**データの量が増えたとき、どれくらい処理時間が増えるか**を表す指標です。

アルゴリズムの効率を測る方法として、主に以下の2つがあります：

* **時間計算量**: 実行にかかる時間（操作の回数）
* **空間計算量**: 使用するメモリの量

今日は主に**時間計算量**に焦点を当てます。

### なぜ計算量が重要なのか？

小さなデータでは、どんなアルゴリズムを使っても処理時間にあまり差はありません。しかし、**データが大きくなると、アルゴリズムの選択が非常に重要**になります。

例えば：

* 10個のデータを整列するなら、どんなソートアルゴリズムを使っても一瞬で終わります
* 1,000,000個のデータを整列する場合、効率の悪いアルゴリズムでは何時間もかかる可能性があります

### 計算量の表し方：ビッグO記法

計算量は一般的に「ビッグO記法」で表現されます。これは「データサイズnに対して、最悪の場合にかかる時間のオーダー」を示します。

主なビッグO記法の例：

* **O(1)**: 定数時間（データサイズに関係なく一定の時間）
* **O(log n)**: 対数時間
* **O(n)**: 線形時間（データサイズに比例）
* **O(n log n)**: 線形対数時間
* **O(n²)**: 二次時間（データサイズの二乗に比例）

### 計算量の比較

計算量を視覚的に表すと、以下のようなグラフになります：

```
処理時間
  ↑            
  │                                               ／O(n²)
  │                                          ／
  │                                     ／
  │                              ／
  │                      ／
  │                ／               ／O(n log n)
  │          ／                ／
  │    ／                 ／
  │                  ／            O(n)
  │              ／        ／
  │          ／    ／
  │      ／／                   O(log n)
  │  ／／_________________________________
  │／                                    O(1)
  └────────────────────────────────────→ データサイズ
```

データサイズが大きくなると、計算量の差がとても大きくなることがわかります。

### これまで学習したアルゴリズムの計算量

#### 探索アルゴリズム

| アルゴリズム | 計算量（最悪の場合） | 特徴                    |
| ------ | ---------- | --------------------- |
| 線形探索   | O(n)       | データサイズに比例して時間が増加      |
| 二分探索   | O(log n)   | データが倍になっても1ステップしか増えない |

#### ソートアルゴリズム

| アルゴリズム  | 計算量（最悪の場合）               | 特徴               |
| ------- | ------------------------ | ---------------- |
| バブルソート  | O(n²)                    | 隣接要素の交換を繰り返す     |
| 選択ソート   | O(n²)                    | 最小値を見つけて順に配置     |
| 挿入ソート   | O(n²)                    | カードを整理するように要素を挿入 |
| マージソート  | O(n log n)               | 分割して統治するアプローチ    |
| クイックソート | O(n log n)（平均）、O(n²)（最悪） | 分割統治法のもう一つの例     |

### データサイズによる処理時間の違い

データサイズが増加したとき、各計算量での処理時間がどれだけ増えるか見てみましょう：

| データサイズ    | O(1) | O(log n) | O(n)      | O(n log n) | O(n²)     |
| --------- | ---- | -------- | --------- | ---------- | --------- |
| 10        | 1    | 3        | 10        | 30         | 100       |
| 100       | 1    | 7        | 100       | 700        | 10,000    |
| 1,000     | 1    | 10       | 1,000     | 10,000     | 1,000,000 |
| 1,000,000 | 1    | 20       | 1,000,000 | 20,000,000 | 10¹²      |

※ 単位は「操作回数」で、実際の時間は環境によって異なります。

### 異なるケースでの計算量

同じアルゴリズムでも、入力データによって計算量が変わることがあります：

#### 挿入ソートの例

* **最良の場合（すでにソートされている）**: O(n)
  * 各要素は比較のみで、移動が不要
* **平均的な場合（ランダムデータ）**: O(n²)
  * 平均して半分の要素と比較
* **最悪の場合（逆順データ）**: O(n²)
  * 各要素がすべての前の要素と比較・移動される

### 適切なアルゴリズムの選択

アルゴリズムの選択は、以下の要素に基づいて行います：

1. **データサイズ**:
   * 小さい場合は単純なアルゴリズムでも十分
   * 大きい場合は効率的なアルゴリズムが必須
2. **データの特性**:
   * ソート済みか？ 部分的にソートされているか？
   * 重複は多いか？
3. **処理の種類**:
   * 一度だけの処理か繰り返し実行するか
   * メモリ制約はあるか

### 現実的な考慮事項

* **定数係数**: O(100n)とO(n²)では、小さなnの場合はO(100n)のほうが遅い
* **実装の複雑さ**: 効率的なアルゴリズムは実装が複雑になりがち
* **メモリ使用量**: 時間を節約するためにメモリを使うことが多い（トレードオフ）

### まとめ

* 計算量は、データサイズに対するアルゴリズムの効率性を表します
* ビッグO記法でアルゴリズムの時間計算量を表現します
* データサイズが大きくなると、効率的なアルゴリズムを選ぶことが重要になります
* アルゴリズムの選択はデータサイズや特性、実行環境などを考慮して行います

次の演習では、実際にコードを実行して計算量の違いを体験してみましょう！
