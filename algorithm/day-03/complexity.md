# アルゴリズムの計算量

### 1. なぜアルゴリズムの効率を考えるのか？

* **問題点:** 同じ問題を解くアルゴリズムは複数存在するが、効率が大きく異なる。
* **データ量の影響:** データ量が増えると、処理時間が急激に増加することがある (例: n件で1秒でも、1万件で数時間)。
  * `[図3.1 入力サイズによる処理時間の違いのグラフ]`
* **実行時間計測の問題点:**
  * 実装しないと評価できない。
  * 実行環境（PCスペック、言語）によって時間が変わってしまう。
* **→ 環境に依存しない評価指標が必要！**

### 2. 計算量とは？

アルゴリズムの性能を評価するための指標。

* **時間計算量 (Time Complexity):** 処理にどれくらいの時間がかかるか（≒ ステップ数）。
* **空間計算量 (Space Complexity):** メモリなどの記憶容量をどれくらい必要とするか。
* **トレードオフ:** 時間を短縮するためにメモリを多く使う、などの関係がある場合も。
  * `[図3.2 時間計算量と空間計算量の概念図]`
* **本日の焦点:** 主に**時間計算量**について学びます。

### 3. 時間計算量の考え方：ステップ数

* 特定の処理（基本単位）が何回実行されるかを数える。
*   **例1: FizzBuzz (1からnまで) - O(n)**

    * ループの中で `print` や `if` がn回実行される。
    * データ量 n に比例してステップ数が増える。

    ```python
    # 例：nまでの数を単純に出力するループ
    def print_numbers(n):
        print("O(n)の例:")
        for i in range(n):
            print(i, end=" ")
        print("\n")

    # print_numbers(10) # n=10なら10回ループ
    # print_numbers(100) # n=100なら100回ループ

    ```
*   **例2: 掛け算九九 (n x n) - O(n²)**

    * 二重ループのため、`print` が n × n 回実行される。
    * データ量 n の **2乗** に比例してステップ数が増える。

    ```python
    # 例：二重ループ
    def print_pairs(n):
        print("O(n^2)の例:")
        count = 0
        for i in range(n): # n回
            for j in range(n): # n回
                # print(f"({i}, {j})", end=" ")
                count += 1 # この処理が n * n 回実行される
        print(f"\nステップ数（目安）: {count}")

    # print_pairs(3) # ステップ数: 9 (3*3)
    # print_pairs(10) # ステップ数: 100 (10*10)

    ```
*   **例3: 体積計算 (n x n x n) - O(n³)**

    * 三重ループのため、`print` が n × n × n 回実行される。
    * データ量 n の **3乗** に比例してステップ数が増える。

    ```python
    # 例：三重ループ
    def print_triples(n):
        print("O(n^3)の例:")
        count = 0
        for i in range(n): # n回
            for j in range(n): # n回
                for k in range(n): # n回
                    # print(f"({i}, {j}, {k})", end=" ")
                    count += 1 # この処理が n * n * n 回実行される
        print(f"\nステップ数（目安）: {count}")

    # print_triples(3) # ステップ数: 27 (3*3*3)
    # print_triples(10) # ステップ数: 1000 (10*10*10)

    ```
* `[図3.3 O(n), O(n²), O(n³) の増加イメージ図]`

### 4. オーダー記法 (O記法 / Big O Notation)

* データ量 n が増えたときに、計算時間（ステップ数）が **どのくらいの勢いで増えるか** を示す記法。
* **目的:** アルゴリズムの性能を大まかに比較しやすくする。
* **考え方:**
  * 最も影響の大きい項（一番増え方が激しい部分）だけを残す。 (例: n² + n なら n² が支配的)
  * 定数倍は無視する (例: 2n も 100n も O(n) と表現)。
* **例:**
  * FizzBuzz (例1): O(n) （線形時間）
  * 掛け算九九 (例2): O(n²) （二乗時間）
  * 体積計算 (例3): O(n³) （三乗時間）

### 5. 代表的なオーダー

<table data-header-hidden><thead><tr><th width="127"></th><th width="169.400146484375"></th><th></th><th></th></tr></thead><tbody><tr><td><strong>オーダー</strong></td><td><strong>名称（例）</strong></td><td><strong>説明</strong></td><td><strong>例</strong></td></tr><tr><td>O(1)</td><td>定数時間</td><td>データ量によらず一定時間</td><td>リストのインデックス参照 <code>my_list[i]</code></td></tr><tr><td>O(log n)</td><td>対数時間</td><td>データが増えても時間はあまり増えない</td><td>二分探索</td></tr><tr><td>O(n)</td><td>線形時間</td><td>データ量に比例して時間が増える</td><td>線形探索、FizzBuzz</td></tr><tr><td>O(n log n)</td><td>線形対数時間</td><td>効率的なソートアルゴリズム</td><td>マージソート、クイックソート</td></tr><tr><td>O(n²)</td><td>二乗時間</td><td>データ量が増えると急激に時間が増える</td><td>バブルソート、選択ソート</td></tr><tr><td>O(n³)</td><td>三乗時間</td><td>さらに急激に時間が増える</td><td>簡単な行列計算</td></tr><tr><td>O(2ⁿ), O(n!)</td><td>指数時間、階乗時間</td><td>データ量が少し増えただけで現実的でなくなる</td><td>巡回セールスマン問題など</td></tr></tbody></table>

**ポイント:** 一般的に、表の上にあるオーダーほど効率が良い（速い）。

### 6. 最悪時間計算量と平均時間計算量

* **最悪時間計算量:** 最も時間がかかる場合の計算量。アルゴリズムの性能保証としてよく使われる。(例: 探索で一番最後に見つかる、または見つからない場合)
* **平均時間計算量:** 様々な入力データに対する平均的な計算量。
* **使い分け:** 最悪ケースが稀なら平均計算量を考慮することもあるが、基本は最悪計算量で評価する。

### 7. データ構造による計算量の違い

アルゴリズムだけでなく、**どのデータ構造を使うか** によっても計算量が変わる。

*   **リスト (配列) vs 連結リスト**

    * `[図3.6 リスト(配列)と連結リストの構造図]`

    <table data-header-hidden><thead><tr><th width="88.00006103515625"></th><th width="106.22213745117188"></th><th width="105.22198486328125"></th><th></th></tr></thead><tbody><tr><td><strong>操作</strong></td><td><strong>リスト</strong></td><td><strong>連結リスト</strong></td><td><strong>理由 (連結リスト)</strong></td></tr><tr><td><strong>挿入</strong></td><td>O(n)</td><td><strong>O(1)</strong></td><td>前後の要素のポインタ（アドレス）を繋ぎ変えるだけ</td></tr><tr><td><strong>削除</strong></td><td>O(n)</td><td><strong>O(1)</strong></td><td>前後の要素のポインタ（アドレス）を繋ぎ変えるだけ</td></tr><tr><td><strong>読取</strong></td><td><strong>O(1)</strong></td><td>O(n)</td><td>先頭から順番にアドレスをたどる必要がある</td></tr></tbody></table>
*   **コードでのイメージ:**

    ```python
    # --- リスト (Pythonのlist) ---
    my_list = [10, 20, 30, 40]

    # 読取 (O(1))
    print(f"リストの2番目の要素: {my_list[1]}") # すぐアクセスできる

    # 挿入 (O(n)) - インデックス1に15を挿入
    print("リストに挿入前:", my_list)
    my_list.insert(1, 15) # 20, 30, 40 を後ろにずらす必要がある
    print("リストに挿入後:", my_list)
    # `[図3.7 リストへの挿入のイメージ図]`

    # 削除 (O(n)) - インデックス2の要素(30)を削除
    print("リストから削除前:", my_list)
    del my_list[2] # 40 を前に詰める必要がある
    print("リストから削除後:", my_list)
    # `[図3.9 リストでの削除のイメージ図]`

    # --- 連結リスト (概念) ---
    # Python標準にはないが、以下のようなイメージ
    # Node(value=10, next=Node2) -> Node(value=20, next=Node3) -> Node(value=30, next=None)

    # 読取 (O(n))
    # 先頭から 'next' をたどって目的のノードを探す必要がある

    # 挿入 (O(1)) - 10と20の間に15を挿入
    # 1. 新しいNode(15)を作成
    # 2. Node(15)のnextをNode(20)に向ける
    # 3. Node(10)のnextをNode(15)に向ける
    # (要素の移動は不要)
    # `[図3.8 連結リストへの挿入のイメージ図]`

    # 削除 (O(1)) - Node(20)を削除
    # 1. Node(10)のnextをNode(20)のnext (つまりNode(30)) に向ける
    # (要素の移動は不要)
    # `[図3.10 連結リストでの削除のイメージ図]`
    ```
* **ポイント:**
  * 挿入・削除が多い場合は連結リストが有利なことがある。
  * 特定の要素へのアクセス（読取）が多い場合はリスト（配列）が有利。
  * どちらが良いかは、行いたい処理によって異なる。

### 8. まとめ

* アルゴリズムの効率を評価するには**計算量**を用いる。
* **オーダー記法 (O記法)** で、データ量増加に対する計算時間の増え方を大まかに把握できる。
* O(1), O(log n), O(n), O(n log n), O(n²) などの代表的なオーダーを知っておくことが重要。
* 使用する**データ構造**によっても計算量が変わるため、適切な選択が必要。
* 効率の良いアルゴリズムとデータ構造を選ぶことで、大規模なデータも扱えるプログラムを作成できる。
