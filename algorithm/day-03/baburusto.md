# バブルソート

### ソート問題とは

ソート問題とは、データの集合（リストなど）を特定の順序（昇順や降順）に並べ替える問題のことです。

* 日常生活の例
  * トランプのカードを数字順に並べる
  * 図書館の本を著者名のアルファベット順に整理する
  * 学生の名簿を五十音順に並び替える
* プログラミングでの重要性
  * データの検索効率の向上（二分探索などの効率的なアルゴリズムが使用可能になる）
  * データの視覚的な理解のしやすさ
  * データ処理や分析の前処理として重要
  * 重複データの特定が容易になる

### 日常生活でのバブルソートの例

#### 例：身長順の並び替え

体育の授業で生徒を身長順に並ばせる方法は、バブルソートの典型的な例です。

* 隣り合う2人ずつを比較する
* 身長の低い人が右にいれば、2人の位置を入れ替える
* 全員を一通り比較し終わったら、最も身長の高い人が左端に来る
* 左端の人を除いて、同じ処理を繰り返す
* 全員が正しい順序で並ぶまで続ける

この「身長順の並び替え」の手順を自然言語で表現すると、

```
# 身長順並び替えの基本的な流れ
1. まだ整列が完了していないとする

2. 整列が完了していない限り:
   a. すべての隣り合う2人を左から順に比較する
   b. 右の人が左の人より身長が高ければ、2人の位置を入れ替える
   c. 一巡して一度も入れ替えが発生しなければ、整列完了とする
```

この方法は泡（バブル）が水中を上昇するように、各要素が少しずつ正しい位置に移動していくことから「バブルソート」と呼ばれています。

### バブルソートのアルゴリズム

#### 基本的な考え方

バブルソート（Bubble Sort）は、隣接する要素同士を比較しながら整列を行うシンプルなソートアルゴリズムです。

* リストの先頭から順に、隣接する2つの要素を比較する
* 順序が逆の場合（昇順なら前の要素が後ろの要素より大きい場合）、2つの要素を交換する
* リストの最後まで到達したら、最大（または最小）の要素がリストの末尾に配置される
* リスト長から1を引いた位置から同じ処理を繰り返す
* すべての要素が正しい位置に配置されるまで、または1回の走査で交換が一度も発生しなくなるまで繰り返す

#### Pythonによる実装

```python
def bubble_sort(arr):
    """
    バブルソートでリストを昇順に並べ替える
    
    引数:
    arr -- ソート対象のリスト
    
    戻り値:
    なし（リストは参照渡しのため、元のリストが変更される）
    """
    n = len(arr)
    
    # 外側のループ：各パスでは1つの要素が正しい位置に配置される
    for i in range(n):
        # 最適化：ソートが完了したことを検出するフラグ
        swapped = False
        
        # 内側のループ：未ソート部分の隣接要素を比較
        for j in range(0, n - i - 1):
            # 隣接する要素を比較し、必要に応じて交換
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # このパスで交換が発生しなかった場合、ソートは完了している
        if not swapped:
            break
```

#### バブルソートの使用例

```python
# 数値のリスト
numbers = [64, 34, 25, 12, 22, 11, 90]
print(f"ソート前: {numbers}")

# バブルソートを実行
bubble_sort(numbers)

# 結果の表示
print(f"ソート後: {numbers}")  # 出力: [11, 12, 22, 25, 34, 64, 90]
```

### バブルソートのステップごとの図解

例えば、リスト `[5, 1, 4, 2, 8]` をソートする過程を示します：

**初期状態**:

```
[5, 1, 4, 2, 8]
```

**パス1**:

```
[5, 1, 4, 2, 8] → [1, 5, 4, 2, 8]  (5 > 1 なので交換)
[1, 5, 4, 2, 8] → [1, 4, 5, 2, 8]  (5 > 4 なので交換)
[1, 4, 5, 2, 8] → [1, 4, 2, 5, 8]  (5 > 2 なので交換)
[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]  (5 < 8 なので交換しない)
```

パス1の結果: `[1, 4, 2, 5, 8]` (最大値8が正しい位置に配置された)

**パス2**:

```
[1, 4, 2, 5, 8] → [1, 4, 2, 5, 8]  (1 < 4 なので交換しない)
[1, 4, 2, 5, 8] → [1, 2, 4, 5, 8]  (4 > 2 なので交換)
[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]  (4 < 5 なので交換しない)
```

パス2の結果: `[1, 2, 4, 5, 8]` (5が正しい位置に配置された)

**パス3**:

```
[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]  (1 < 2 なので交換しない)
[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]  (2 < 4 なので交換しない)
```

パス3の結果: `[1, 2, 4, 5, 8]` (4が正しい位置に配置された)

**パス4**:

```
[1, 2, 4, 5, 8] → [1, 2, 4, 5, 8]  (1 < 2 なので交換しない)
```

パス4の結果: `[1, 2, 4, 5, 8]` (2が正しい位置に配置された)

このパスでは交換が一度も発生しなかったため、リストは既にソートされていると判断してアルゴリズムを終了します。

### フローチャートと疑似コード

#### バブルソートのフローチャート

バブルソートのアルゴリズムをフローチャートで表現すると、以下のようになります。

```
開始
  ↓
[n = 配列の長さ]
  ↓
[i = 0で初期化（ソートパス数）]
  ↓
< i < n ? > ---> NO ---> [ソート完了]
  | YES                    ↓
  ↓                      終了
[swapped = FALSE で初期化]
  ↓
[j = 0で初期化（比較位置）]
  ↓
< j < n - i - 1 ? > ---> NO ---> < swapped = TRUE ? > ---> NO ---> [i = i + 1]
  | YES                               | YES                           ↓
  ↓                                   ↓                    (外側ループの先頭に戻る)
< arr[j] > arr[j+1] ? >           [i = i + 1]
  | YES            | NO             ↓
  ↓               ↓           (外側ループの先頭に戻る)
[arr[j]とarr[j+1]を交換]
  ↓
[swapped = TRUE]
  ↓
[j = j + 1]
  |
  +---> (内側ループの先頭に戻る)
```

#### バブルソートの疑似コード

バブルソートのアルゴリズムを、特定のプログラミング言語に依存しない「疑似コード」で表現すると以下のようになります。

```
procedure bubble_sort(arr):
    n = length(arr)
    
    // 外側のループ：n回のパスを実行（最適化により減る可能性あり）
    for i from 0 to n-1:
        // 最適化：ソートが完了したことを検出するフラグ
        swapped = false
        
        // 内側のループ：未ソート部分の隣接要素を比較
        for j from 0 to n-i-2:
            // 隣接する要素を比較し、必要に応じて交換
            if arr[j] > arr[j+1]:
                swap arr[j] and arr[j+1]
                swapped = true
        
        // このパスで交換が発生しなかった場合、ソートは完了している
        if not swapped:
            break
```

### バブルソートの特徴

#### メリット

* 実装が非常にシンプル  \
  アルゴリズムの考え方が直感的で、初心者でも理解しやすく、数行のコードで実装できます。
* 安定ソート  \
  同じ値を持つ要素の相対的な順序が保持されます（安定ソート）。
* インプレースソート  \
  追加のメモリ領域をほとんど必要とせず、元のリスト上で直接ソートができます。
* 早期終了の最適化が可能  \
  リストが既にソートされている場合、1回のパスで検出して終了できます。
* 部分的にソートされたデータに対して比較的効率的  \
  ほとんどの要素が正しい位置にある場合、必要な交換回数が少なくなります。

#### デメリット

* 非効率性  \
  時間計算量がO(n²)で、大きなデータセットでは極めて非効率です。
* 交換回数の多さ  \
  要素の交換回数が多く、これによりメモリへの書き込みオーバーヘッドが発生します。
* 他のシンプルなアルゴリズムと比較しても遅い  \
  選択ソートや挿入ソートなど、同じO(n²)の時間計算量を持つ他のソートアルゴリズムと比較しても、通常は遅い傾向があります。

#### 計算量

* **時間計算量**:
  * 最良の場合: O(n) - データが既にソートされている場合（早期終了の最適化あり）
  * 平均的な場合: O(n²)
  * 最悪の場合: O(n²) - データが逆順にソートされている場合
* **空間計算量**: O(1) - 追加のメモリをほとんど使用しません

#### バブルソートの使い所

以下の状況では、バブルソートが適しているか、選択肢の一つとなります。

* 教育目的でソートアルゴリズムを学ぶ場合
* 非常に小さなデータセット（要素数が少ない）の場合
* 追加のメモリ使用を避けたい場合
* 既にほとんどソートされているデータでの使用
* 安定ソートが必要な場合
* 実装の単純さが最優先される場合

### よくあるエラーと注意点

*   **ループ範囲の誤り**

    ```python
    # 間違い
    for j in range(0, n - i):  # 配列の範囲外にアクセスする可能性

    # 正しい
    for j in range(0, n - i - 1):  # 正しく範囲を設定
    ```
*   **最適化の欠如**

    ```python
    # 非効率 - 早期終了の最適化なし
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

    # 効率的 - 早期終了の最適化あり
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    ```
*   **不要なパスの実行**

    ```python
    # 非効率 - 常にn回のパスを実行
    for i in range(n):
        # パスの処理

    # 効率的 - 必要なパスのみ実行
    for i in range(n):
        # パスの処理
        if not swapped:  # 交換が発生しなかった場合
            break  # ソート完了として終了
    ```
*   **比較演算子の誤り**

    ```python
    # 間違い（昇順ソートの場合）
    if arr[j] < arr[j + 1]:  # 降順ソートの条件
        arr[j], arr[j + 1] = arr[j + 1], arr[j]

    # 正しい（昇順ソートの場合）
    if arr[j] > arr[j + 1]:  # 正しい比較条件
        arr[j], arr[j + 1] = arr[j + 1], arr[j]
    ```
*   **交換の実装ミス**

    ```python
    # 間違い - 値が失われる
    if arr[j] > arr[j + 1]:
        arr[j + 1] = arr[j]  # 元のarr[j+1]の値が失われる
        arr[j] = arr[j + 1]  # arr[j]に代入されるのは既に上書きされたarr[j+1]

    # 正しい - 一時変数を使用
    if arr[j] > arr[j + 1]:
        temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp

    # または、Pythonのタプル代入を使用
    if arr[j] > arr[j + 1]:
        arr[j], arr[j + 1] = arr[j + 1], arr[j]
    ```
